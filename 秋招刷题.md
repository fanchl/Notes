# CodeTop

首先按照 Codetop 算法岗顺序刷题，前面的部分大多是之前已经做过的，因此要求每天至少 5 道。

## 0629

### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

**优先队列**  
定义优先队列的方式 `priority_queue<int, vector<int>, greater<int>>`，其中 `greater` 可以理解为队列中存储的是较大的元素。

```C++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, greater<int>> pq;
        for (int i = 0; i < nums.size(); i++) {
            if (pq.size() < k) {
                pq.push(nums[i]);
            } else if (pq.top() < nums[i]) {
                pq.pop();
                pq.push(nums[i]);
            }
        }
        return pq.top();
    }
};
```

### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

**二维动态规划**  
创建一个二维数组，并且多创建一行和一列，方便之后不用考虑出界的问题。到某个位置的编辑距离，可以由上一个位置的编辑距离再加上编辑该字符所需要的步数，取所有可能的最小值。

```C++
class Solution {
public:
    int minDistance(string word1, string word2) {
        if (word1.size() * word2.size() == 0) return word1.size() + word2.size();
        vector<vector<int>> dist(word1.size() + 1, vector<int>(word2.size() + 1));
        for (int i = 0; i < word1.size() + 1; i++) {
            dist[i][0] = i;
        }
        for (int j = 0; j < word2.size() + 1; j++) {
            dist[0][j] = j;
        }

        for (int i = 1; i < word1.size() + 1; i++) {
            for (int j = 1; j < word2.size() + 1; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dist[i][j] = min(dist[i - 1][j - 1], min(dist[i - 1][j] + 1, dist[i][j - 1] + 1));
                } else {
                    dist[i][j] = min(dist[i - 1][j - 1] + 1, min(dist[i - 1][j] + 1, dist[i][j - 1] + 1));
                }
            }
        }
        return dist[word1.size()][word2.size()];
    }
};
```

### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

**DFS**  
可以将网格看作是树，子节点是周围的四个网格，但有的网格处在边界位置，因此需要判断子节点是否存在（是否在网格之外），以及子节点是否为土地（该网格是否为'1'）。

```C++
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        if (grid.size() == 0) return 0;
        if (grid[0].size() == 0) return 0;
        int cnt = 0;
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[0].size(); j++) {
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    cnt++;
                }
            }
        }
        return cnt;
    }

    void dfs(vector<vector<char>>& grid, int i, int j) {
        if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == '0') return;
        grid[i][j] = '0';
        dfs(grid, i - 1, j);
        dfs(grid, i + 1, j);
        dfs(grid, i, j - 1);
        dfs(grid, i, j + 1);
    }
};
```

### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

**迭代**  
定义 `pre, cur, next`。

```C++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* cur = head;
        while (cur != nullptr) {
            ListNode* next = cur -> next;
            cur -> next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
};
```

<<<<<<< HEAD

### [15. 三数之和](https://leetcode.cn/problems/3sum/)

**双指针**  
将数组排序，固定一个指针 k 在前面，双指针移动 i 和 j，有一些情况需要剪枝。  

+ `nums[k] > 0`： 则总和肯定大于 0，可以直接跳过；
+ 需要跳过与上一个元素相同的元素，避免重复添加结果。

```C++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        if (nums.size() < 3) return res;
        sort(nums.begin(), nums.end());    
        for (int k = 0; k < nums.size() - 2; k++) {
            if (k > 0 && nums[k] == nums[k - 1]) continue;
            if (nums[k] > 0) break;
            int i = k + 1, j = nums.size() - 1;
            while (i < j) {
                if (nums[k] + nums[i] + nums[j] < 0) {
                    i++;
                    while (i < j && nums[i] == nums[i - 1]) i++;
                } else if (nums[k] + nums[i] + nums[j] > 0) {
                    j--;
                    while (i < j && nums[j] == nums[j + 1]) j--;
                } else {
                    res.push_back(vector<int>{nums[k], nums[i], nums[j]});
                    i++;
                    while (i < j && nums[i] == nums[i - 1]) i++;
                    j--;
                    while (i < j && nums[j] == nums[j + 1]) j--;
                }
            }
        }
        return res;
    }
};
```

=======

### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

**动态规划**  
创建一个一维数组，其中每一个元素表示**包含当前元素**的最大子数组和。

```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        int res = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]);
            res = max(dp[i], res);
        }
        return res;
    }
};
```

**动态规划空间降维**  
在动态规划方法中，只会用到上一个位置的子数组最大和的中间值，因此可以直接用变量来实现。

```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int res = nums[0], pre = nums[0];
        int cur;
        for (int i = 1; i < nums.size(); i++) {
            cur = max(pre + nums[i], nums[i]);
            res = max(cur, res);
            pre = cur;
        }
        return res;
    }
};
```

**贪心法**  
记录 res 初始值为 IMT_MIN，定义 sum 为当前位置的最大和，如果加了当前值的 sum 小于 0 之后，将 sum 置 0 （其实就相当于在下一次迭代中，sum 为 nums[i+1]）

```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int res = INT_MIN, sum = 0;
        for (int i = 0; i < nums.size(); i++) {
            sum +=  nums[i];
            res = max(sum, res);
            if (sum < 0) {
                sum = 0;
            }
        }
        return res;
    }
};
```

>>>>>>> 82eba38d218bde30673cc3082fa0f007eb9f6c06