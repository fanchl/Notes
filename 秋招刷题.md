# CodeTop

首先按照 Codetop 算法岗顺序刷题，前面的部分大多是之前已经做过的，因此要求每天至少 5 道。

## 0629

### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

**优先队列**  
定义优先队列的方式 `priority_queue<int, vector<int>, greater<int>>`，其中 `greater` 可以理解为队列中存储的是较大的元素。

```C++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, greater<int>> pq;
        for (int i = 0; i < nums.size(); i++) {
            if (pq.size() < k) {
                pq.push(nums[i]);
            } else if (pq.top() < nums[i]) {
                pq.pop();
                pq.push(nums[i]);
            }
        }
        return pq.top();
    }
};
```

### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

**二维动态规划**  
创建一个二维数组，并且多创建一行和一列，方便之后不用考虑出界的问题。到某个位置的编辑距离，可以由上一个位置的编辑距离再加上编辑该字符所需要的步数，取所有可能的最小值。

```C++
class Solution {
public:
    int minDistance(string word1, string word2) {
        if (word1.size() * word2.size() == 0) return word1.size() + word2.size();
        vector<vector<int>> dist(word1.size() + 1, vector<int>(word2.size() + 1));
        for (int i = 0; i < word1.size() + 1; i++) {
            dist[i][0] = i;
        }
        for (int j = 0; j < word2.size() + 1; j++) {
            dist[0][j] = j;
        }

        for (int i = 1; i < word1.size() + 1; i++) {
            for (int j = 1; j < word2.size() + 1; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dist[i][j] = min(dist[i - 1][j - 1], min(dist[i - 1][j] + 1, dist[i][j - 1] + 1));
                } else {
                    dist[i][j] = min(dist[i - 1][j - 1] + 1, min(dist[i - 1][j] + 1, dist[i][j - 1] + 1));
                }
            }
        }
        return dist[word1.size()][word2.size()];
    }
};
```

