# CodeTop

首先按照 Codetop 算法岗顺序刷题，前面的部分大多是之前已经做过的，因此要求每天至少 5 道。

## 0629

### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

**优先队列**  
定义优先队列的方式 `priority_queue<int, vector<int>, greater<int>>`，其中 `greater` 可以理解为队列中存储的是较大的元素。

```C++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, greater<int>> pq;
        for (int i = 0; i < nums.size(); i++) {
            if (pq.size() < k) {
                pq.push(nums[i]);
            } else if (pq.top() < nums[i]) {
                pq.pop();
                pq.push(nums[i]);
            }
        }
        return pq.top();
    }
};
```

### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

**二维动态规划**  
创建一个二维数组，并且多创建一行和一列，方便之后不用考虑出界的问题。到某个位置的编辑距离，可以由上一个位置的编辑距离再加上编辑该字符所需要的步数，取所有可能的最小值。

```C++
class Solution {
public:
    int minDistance(string word1, string word2) {
        if (word1.size() * word2.size() == 0) return word1.size() + word2.size();
        vector<vector<int>> dist(word1.size() + 1, vector<int>(word2.size() + 1));
        for (int i = 0; i < word1.size() + 1; i++) {
            dist[i][0] = i;
        }
        for (int j = 0; j < word2.size() + 1; j++) {
            dist[0][j] = j;
        }

        for (int i = 1; i < word1.size() + 1; i++) {
            for (int j = 1; j < word2.size() + 1; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dist[i][j] = min(dist[i - 1][j - 1], min(dist[i - 1][j] + 1, dist[i][j - 1] + 1));
                } else {
                    dist[i][j] = min(dist[i - 1][j - 1] + 1, min(dist[i - 1][j] + 1, dist[i][j - 1] + 1));
                }
            }
        }
        return dist[word1.size()][word2.size()];
    }
};
```

### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

**DFS**  
可以将网格看作是树，子节点是周围的四个网格，但有的网格处在边界位置，因此需要判断子节点是否存在（是否在网格之外），以及子节点是否为土地（该网格是否为'1'）。

```C++
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        if (grid.size() == 0) return 0;
        if (grid[0].size() == 0) return 0;
        int cnt = 0;
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[0].size(); j++) {
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    cnt++;
                }
            }
        }
        return cnt;
    }

    void dfs(vector<vector<char>>& grid, int i, int j) {
        if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == '0') return;
        grid[i][j] = '0';
        dfs(grid, i - 1, j);
        dfs(grid, i + 1, j);
        dfs(grid, i, j - 1);
        dfs(grid, i, j + 1);
    }
};
```

